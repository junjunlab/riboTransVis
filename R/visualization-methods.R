# ==============================================================================
# visualization
# ==============================================================================


#' @title Visualize transcript signals
#'
#' @description Generic function definition for visualizing transcript-level signals, including ribosome occupancy and RNA-seq coverage.
#'
#' @param object The main object containing required data for visualization. Typically an S4 class object, such as `ribotrans`.
#' @param ... Additional parameters to be used in specific method implementations.
#'
#' @seealso \code{\link{trans_plot,ribotrans-method}} for the method implementation specific to the `ribotrans` class.
#' @export
#' @rdname trans_plot
setGeneric("trans_plot",function(object,...) standardGeneric("trans_plot"))



#' @title Plot transcript-based ribosome profiling and RNA-seq results
#'
#' @description Method implementation for `trans_plot`, specifically for objects of class `ribotrans`.
#'
#' @param object An S4 object of class `ribotrans`, containing ribosome profiling data, RNA-seq data, and gene annotation features.
#' @param selected_id A character vector of specific transcript IDs to plot. Defaults to \code{NULL}, where all transcripts associated with the gene are plotted.
#' @param type A character string specifying the type of plot to generate.
#'   Possible values are:
#'   \itemize{
#'     \item \code{"ribo"}: Ribosome footprint data.
#'     \item \code{"rna"}: RNA-seq data.
#'     \item \code{"ribo_rna"}: Ribosome occupancy normalized by RNA-seq (scaled by \code{scale_factor}).
#'     \item \code{"scaled_ribo"}: Scaled ribosome occupancy over RNA.
#'   }
#' @param layer A character string defining the plot layer. Options are:
#'   \itemize{
#'     \item \code{"line"}: Line plot.
#'     \item \code{"col"}: Bar (column) plot.
#'   }
#' @param sample_order The sample orders to be plotted.  Default: `NULL`.
#' @param facet_layer ggplot2 faceting specification, default facet_grid(sample~rname,switch = "y").
#' @param sep_mer_sample  Logical. Whether show samples separately and merged for different panels. Default: `FALSE`.
#' @param new_signal_range Logical. If `TRUE`, adds a signal range annotation to the plot. Default: `TRUE`.
#' @param position_mode Character, position display mode. One of:
#'   * "nt": nucleotide positions
#'   * "codon": codon positions.
#' @param range_x Numerics specifying the x position of the signal range annotation
#'   in normalized parent coordinates `[0, 1]`. Default: `0.98`.
#' @param range_y Numerics specifying the y position of the signal range annotation
#'   in normalized parent coordinates `[0, 1]`. Default: `0.98`.
#' @param range_size Numeric. Text size for the signal range label. Default: `4`.
#' @param range_digit Numeric. Number of decimal places for rounding signal range values. Default: `1`.
#' @param scale_factor Numeric, a scaling factor for RNA-seq reads when \code{type = "ribo_rna"} (default = 1.0).
#' @param utr_width Numeric, the line width for untranslated regions (UTRs) in the transcript structure (default = 1.0).
#' @param cds_width Numeric, the line width for coding sequences (CDS) in the transcript structure (default = 3.0).
#' @param utr_col Character, the color to use for UTR regions (default = "grey").
#' @param cds_col Character, the color to use for CDS regions (default = "grey30").
#' @param nrow Integer, the number of rows for arranging plots in a grid layout (default = \code{NULL}, auto-calculated).
#' @param ncol Integer, the number of columns for arranging plots in a grid layout (default = \code{NULL}, auto-calculated).
#'
#' @return A combined ggplot object or a plot grid as generated by `cowplot::plot_grid`, representing transcript plots with annotations.
#'
#' @details
#' This method facilitates visualizing transcript-level data from ribosome footprint profiling and RNA-seq analyses. The `type` parameter enables viewing raw ribosome or RNA data and scaled metrics. Annotations, such as UTR and CDS regions, are included for transcript-specific structural context.
#'
#' The plots are arranged in facets by sample and transcript ID, and plotting options (lines or bars) are easily customizable via the `layer` parameter.
#'
#' @seealso \code{\link{trans_plot}} for the generic function definition.
#'
#' @examples
#' \dontrun{
#' # Plot ribosome footprint occupancy
#' trans_plot(ribo_obj, type = "ribo")
#'
#' # Plot RNA coverage with custom sample order
#' trans_plot(ribo_obj, type = "rna",
#'           sample_order = c("Sample1", "Sample2"))
#'
#' # Plot combined ribo-RNA view in codon mode
#' trans_plot(ribo_obj, type = "ribo_rna",
#'           position_mode = "codon")
#' }
#'
#' @import ggplot2
#' @importFrom ggside geom_xsidesegment scale_xsidey_continuous ggside
#' @export
#' @rdname trans_plot
setMethod("trans_plot",
          signature(object = "ribotrans"),
          function(object,
                   selected_id = NULL,
                   type = c("ribo","rna","ribo_rna","scaled_ribo"),
                   layer = c("line", "col"),
                   sample_order = NULL,
                   facet_layer = ggplot2::facet_grid(sample~rname,switch = "y"),
                   sep_mer_sample = FALSE,
                   new_signal_range = TRUE,
                   position_mode = c("nt", "codon"),
                   range_x = 0.98,
                   range_y = 0.98,
                   range_size = 4,
                   range_digit = 1,
                   scale_factor = 1,
                   utr_width = 1,
                   cds_width = 3,
                   utr_col = "grey",
                   cds_col = "grey30",
                   nrow = NULL,ncol = NULL){
            # check plot type
            type <- match.arg(type,choices = c("ribo","rna","ribo_rna","scaled_ribo"))
            layer <- match.arg(layer, choices = c("line", "col"))
            position_mode <- match.arg(position_mode, choices = c("nt", "codon"))

            if(type == "ribo"){
              # check data
              if(nrow(object@ribo_occupancy) == 0){
                stop("Please run `get_occupancy` first!")
              }

              pldf <- object@ribo_occupancy
              ylab <- "Ribsome footprint occupancy (RPM)"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample,color = sample),width = 1)
              }

              col <- NULL
            }else if(type == "rna"){
              # check data
              if(nrow(object@RNA_coverage) == 0){
                stop("Please run `get_coverage` first!")
              }

              pldf <- object@RNA_coverage
              ylab <- "RNA reads coverage (RPM)"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample,color = sample),width = 1)
              }

              col <- NULL
            }else if(type == "ribo_rna"){
              ylab <- "Ribsome footprint occupancy \n (RNA reads coverage)"

              # check data
              if(nrow(object@ribo_occupancy) == 0){
                stop("Please run `get_occupancy` first!")
              }

              # check data
              if(nrow(object@RNA_coverage) == 0){
                stop("Please run `get_coverage` first!")
              }

              ribo <- object@ribo_occupancy
              ribo$exp <- "ribo"
              rna <- object@RNA_coverage
              rna$exp <- "rna"
              rna$smooth <- rna$smooth*scale_factor

              pldf <- rbind(ribo, rna)
              pldf$exp <- factor(pldf$exp,levels = c("rna","ribo"))

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
                col <- scale_color_manual(values = c("ribo" = "red", "rna" = "grey"))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample,color = sample),width = 1)
                col <- scale_fill_manual(values = c("ribo" = "red", "rna" = "grey"))
              }

            }else if(type == "scaled_ribo"){
              ylab <- "Scaled ribosome footprint occupancy"

              # check data
              if(nrow(object@scaled_occupancy) == 0){
                stop("Please run `get_scaled_occupancy` first!")
              }


              pldf <- object@scaled_occupancy

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample,color = sample),width = 1)
              }

              col <- NULL
            }


            # filter genes
            tanno <- object@features %>%
              dplyr::filter(gene == object@gene_name) %>%
              dplyr::mutate(rname = idnew)

            if(is.null(selected_id)){
              tids <- tanno$idnew
            }else{
              tids <- selected_id
            }

            # ==================================================================
            # loop plot for each transcript
            # x = 1
            lapply(seq_along(tids),function(x){
              tmp.df <- subset(pldf, rname == tids[x])
              tanno.tmp <- subset(tanno, rname == tids[x])

              # check position_mode
              if(position_mode == "codon"){
                tmp.df <- tmp.df %>%
                  dplyr::filter(pos >= tanno.tmp$mstart & pos <= tanno.tmp$mstop) %>%
                  dplyr::mutate(pos = pos - tanno.tmp$mstart + 1) %>%
                  dplyr::mutate(codon = (pos - 1) %/% 3 + 1) %>%
                  dplyr::group_by(sample,rname,codon) %>%
                  dplyr::summarise(smooth = mean(smooth)) %>%
                  dplyr::rename(pos = codon)

                xlab <- "Position along transcript (codon/AA)"

                struc_layer1 <-
                  geom_xsidesegment(data = tanno.tmp,
                                    aes(x = 1,xend = tanno.tmp$cds/3,y = 0.5,yend = 0.5),
                                    linewidth = cds_width,color = cds_col)
                struc_layer2 <- NULL
              }else{
                xlab <- "Position along transcript (nt)"

                struc_layer1 <-
                  geom_xsidesegment(data = tanno.tmp,
                                    aes(x = 1,xend = translen,y = 0.5,yend = 0.5),
                                    linewidth = utr_width,color = utr_col)
                struc_layer2 <-
                  geom_xsidesegment(data = tanno.tmp,
                                    aes(x = mstart,xend = mstop,y = 0.5,yend = 0.5),
                                    linewidth = cds_width,color = cds_col)
              }

              # whether add new signal range
              if(new_signal_range == TRUE){
                axis.text.y = element_blank()
                axis.ticks.y = element_blank()

                range <- paste("[0-",round(max(tmp.df$smooth),digits = range_digit),"]",sep = "")

                if (requireNamespace("ggpp", quietly = TRUE)) {
                  range_label <- ggpp::annotate(geom = "text_npc",
                                                npcx = range_x,npcy = range_y,
                                                label = range,
                                                size = range_size)
                } else {
                  warning("Package 'ggpp' is needed for this function to work.")
                }

              }else{
                axis.text.y = NULL
                axis.ticks.y = NULL
                range_label <- NULL
              }

              # whether show merged sample and seperate sample together
              if(sep_mer_sample == TRUE){
                tmp.df2 <- tmp.df
                tmp.df2$sp <- "merged sample"

                tmp.df$sp <- tmp.df$sample
                tmp.df <- rbind(tmp.df2, tmp.df)

                facet_layer <- ggplot2::facet_grid(sp~rname,switch = "y")
              }

              # sample orders
              if(!is.null(sample_order)){
                if(sep_mer_sample == TRUE){
                  tmp.df$sp <- factor(tmp.df$sp ,levels = c(sample_order,"merged sample"))
                }else{
                  tmp.df$sample <- factor(tmp.df$sample ,levels = sample_order)
                }

              }

              # plot
              p <-
                ggplot(tmp.df) +
                player +
                range_label +
                theme_bw() +
                # facet_wrap(~sample,scales = "fixed",ncol = 1,switch = "y") +
                facet_layer +
                theme(panel.grid = element_blank(),
                      axis.text = element_text(colour = "black"),
                      strip.text = element_text(colour = "black",size = rel(1)),
                      strip.text.x = element_text(face = "bold",colour = "black",size = rel(1)),
                      strip.background = element_blank(),
                      strip.placement = "outside",
                      strip.text.y.left = element_text(angle = 0,hjust = 1),
                      axis.text.y = axis.text.y,
                      axis.ticks.y = axis.ticks.y,
                      ggside.panel.background = element_blank(),
                      ggside.panel.border = element_blank()) +
                # gene structure
                struc_layer1 + struc_layer2 +
                ggside::scale_xsidey_continuous(breaks = NULL) +
                xlab(xlab) +
                ylab(ylab) +
                ggside(collapse = "x") +
                col

              return(p)
            }) -> plist

            # combine plot list
            if (requireNamespace("cowplot", quietly = TRUE)) {
              cowplot::plot_grid(plotlist = plist,nrow = nrow,ncol = ncol)
            } else {
              warning("Package 'cowplot' is needed for this function to work.")
            }


          }
)




# ==============================================================================
# function to visualize coverage and occupancy on genome
# ==============================================================================

#' @title Generic function for genome transcript plotting
#'
#' @description
#' This generic function serves as an interface for plotting genomic transcripts.
#' It allows specific methods to be applied depending on the class of the object provided.
#'
#' @param object An object of class \code{ribotrans}, or other classes with defined methods for genome transcript plotting.
#' @param ... Additional arguments passed to specific methods.
#'
#' @return A ggplot object or other relevant output depending on the method used.
#'
#' @export
#' @rdname genome_trans_plot
setGeneric("genome_trans_plot",function(object,...) standardGeneric("genome_trans_plot"))




#' @title Method for plotting genomic transcripts for ribotrans objects
#'
#' @description
#' This method generates genomic plots for ribosomal occupancy and RNA reads coverage
#' based on the specified parameters for objects of class \code{ribotrans}.
#'
#' @param object An object of class \code{ribotrans} containing the necessary data for plotting.
#' @param selected_id (optional) A specific transcript id for the gene of interest. Default is NULL.
#' @param type A character string indicating the type of data to plot. Choices are "ribo" for
#' ribosomal occupancy, "rna" for RNA coverage, or "ribo_rna" for both. Default is "ribo".
#' @param layer A character string indicating the plot layer type, either "col" for `geom_col` plots
#' or "line" for `geom_path` plots. Default is "col".
#' @param sample_order (optional) A character vector specifying the order in which samples should be
#' displayed in the plot. Default is NULL.
#' @param facet_layer A facet layer for ggplot, default is \code{ggplot2::facet_grid(sample~rname,switch = "y")}.
#' @param sep_mer_sample A boolean indicating whether to separate merged and individual samples. Default is FALSE.
#' @param new_signal_range A boolean indicating whether to show the new signal range on the plot. Default is FALSE.
#' @param collapse_structure A boolean indicating whether to collapse the structures of transcripts and exons into a single line in the plot. Default is FALSE.
#' @param range_x A numeric value specifying the position adjustment for the range label on the x-axis. Default is 0.9.
#' @param range_y A numeric value specifying the position adjustment for the range label on the y-axis. Default is 0.9.
#' @param range_size A numeric value specifying the font size for the range label. Default is 4.
#' @param range_digit An integer indicating the number of digits to round the range label. Default is 1.
#' @param scale_factor A scaling factor to adjust RNA coverage values for better visualization. Default is 1.
#' @param utr_width A numeric value to specify the width of the UTR segments in the plot. Default is 1.
#' @param cds_width A numeric value to specify the width of the CDS segments in the plot. Default is 3.
#' @param background_line A vector defining the color and linewidth for the background line structure. Default is \code{c("black", 0.25)}.
#' @param exon_line A vector defining the color and linewidth for the exon line structure. Default is \code{c("#003399", 1)}.
#' @param cds_line A vector defining the color and linewidth for the CDS line structure. Default is \code{c("#003399", 3)}.
#' @param structure_panel_height A numeric value specifying the height of the structure panel in the plot. Default is 0.2.
#'
#' @return A ggplot object displaying the genomic transcripts along with ribosome occupancy or RNA coverage data.
#'
#' @details The function uses ggplot2 for visualization and requires specific data to be pre-calculated (e.g., ribosome occupancy or RNA coverage). Users must ensure that the appropriate methods (such as \code{get_occupancy} or \code{get_coverage}) have been executed prior to plotting.
#'
#' @examples
#' \dontrun{
#' # Assuming 'ribotrans_obj' is a pre-defined ribotrans object
#' genome_trans_plot(
#'   object = ribotrans_obj,
#'   type = "ribo",
#'   layer = "col",
#'   sample_order = c("sample1", "sample2", "merged_sample"),
#'   collapse_structure = TRUE
#' )
#' }
#'
#' @import ggplot2
#' @import dplyr
#' @importFrom ggside scale_xsidey_continuous
#' @importFrom ggside ggside
#'
#' @export
#' @rdname genome_trans_plot
setMethod("genome_trans_plot",
          signature(object = "ribotrans"),
          function(object,
                   selected_id = NULL,
                   type = c("ribo","rna","ribo_rna"),
                   layer = c("col", "line"),
                   sample_order = NULL,
                   facet_layer = ggplot2::facet_grid(sample~rname,switch = "y"),
                   sep_mer_sample = FALSE,
                   new_signal_range = FALSE,
                   collapse_structure = FALSE,
                   range_x = 0.9,
                   range_y = 0.9,
                   range_size = 4,
                   range_digit = 1,
                   scale_factor = 1,
                   utr_width = 1,
                   cds_width = 3,
                   background_line = c("black",0.25),
                   exon_line = c("#003399",1),
                   cds_line = c("#003399",3),
                   structure_panel_height = 0.2){
            # check plot type
            type <- match.arg(type,choices = c("ribo","rna","ribo_rna"))
            layer <- match.arg(layer, choices = c("col", "line"))

            if(type == "ribo"){
              # check data
              if(nrow(object@ribo_occupancy) == 0){
                stop("Please run `get_occupancy` first!")
              }

              pldf <- object@ribo_occupancy
              ylab <- "Ribsome footprint occupancy (RPM)"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- scale_fill_manual(values = rep("black",length(unique(pldf$sample))))
            }else if(type == "rna"){
              # check data
              if(nrow(object@RNA_coverage) == 0){
                stop("Please run `get_coverage` first!")
              }

              pldf <- object@RNA_coverage
              ylab <- "RNA reads coverage (RPM)"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- scale_fill_manual(values = rep("black",length(unique(pldf$sample))))
            }else if(type == "ribo_rna"){
              ylab <- "Ribsome footprint occupancy \n (RNA reads coverage)"

              # check data
              if(nrow(object@ribo_occupancy) == 0){
                stop("Please run `get_occupancy` first!")
              }

              # check data
              if(nrow(object@RNA_coverage) == 0){
                stop("Please run `get_coverage` first!")
              }

              ribo <- object@ribo_occupancy
              ribo$exp <- "ribo"
              rna <- object@RNA_coverage
              rna$exp <- "rna"
              rna$smooth <- rna$smooth*scale_factor

              pldf <- rbind(ribo, rna)
              pldf$exp <- factor(pldf$exp,levels = c("rna","ribo"))

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = exp))
                col <- scale_color_manual(values = c("ribo" = "red", "rna" = "grey50"))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = exp),width = 1)
                col <- scale_fill_manual(values = c("ribo" = "red", "rna" = "grey50"))
              }

            }


            # ==================================================================
            # structure layers
            # ==================================================================
            # add region structure
            gene_anno <- data.frame(object@gtf_data) %>%
              dplyr::filter(gene_name == object@gene_name)

            # check selected_id
            if(!is.null(selected_id)){
              gene_anno <- gene_anno %>%
                dplyr::filter(transcript_id %in% selected_id)
            }

            # add label
            chr <- ifelse(startsWith(as.character(gene_anno$seqnames[1]),"chr"),
                          as.character(gene_anno$seqnames[1]),
                          paste("chr",gene_anno$seqnames[1],sep = ""))

            pldf$rname <- paste(object@gene_name, " ",
                                chr,":",min(gene_anno$start),"-",max(gene_anno$end),sep = "")

            # ==================================================================
            # transcript background line
            sruc_trans_rg <- gene_anno %>%
              dplyr::filter(gene_name == object@gene_name & type == "transcript") %>%
              dplyr::mutate(group_id = dplyr::dense_rank(transcript_id))

            # check expand structure
            if(collapse_structure == TRUE){
              bg.layer <- geom_xsidesegment(data = sruc_trans_rg,
                                            aes(x = start,xend = end,y = 1,yend = 1),
                                            linewidth = as.numeric(background_line[2]),
                                            color = background_line[1])

              sturc_limit <- c(0,2)
            }else{
              bg.layer <- geom_xsidesegment(data = sruc_trans_rg,
                                            aes(x = start,xend = end,y = group_id,yend = group_id),
                                            linewidth = as.numeric(background_line[2]),
                                            color = background_line[1])

              sturc_limit <- c(0,nrow(sruc_trans_rg) + 1)
            }



            # ==================================================================
            # exons
            sruc_rg <- gene_anno %>%
              dplyr::filter(gene_name == object@gene_name & type == "exon") %>%
              dplyr::mutate(group_id = dplyr::dense_rank(transcript_id))

            # add exon structure
            if(collapse_structure == TRUE){
              exon.layer <- geom_xsidesegment(data = sruc_rg,
                                              aes(x = start,xend = end,y = 1,yend = 1),
                                              linewidth = as.numeric(exon_line[2]),
                                              color = exon_line[1])
            }else{
              exon.layer <- geom_xsidesegment(data = sruc_rg,
                                              aes(x = start,xend = end,y = group_id,yend = group_id),
                                              linewidth = as.numeric(exon_line[2]),
                                              color = exon_line[1])
            }


            # ================================================================
            # cds
            sruc_cds_rg <- gene_anno %>%
              dplyr::filter(gene_name == object@gene_name & type == "CDS") %>%
              dplyr::mutate(group_id = dplyr::dense_rank(transcript_id))

            # add cds structure
            if(nrow(sruc_cds_rg) > 0){
              if(collapse_structure == TRUE){
                cds.layer <- geom_xsidesegment(data = sruc_cds_rg,
                                               aes(x = start,xend = end,y = 1,yend = 1),
                                               linewidth = as.numeric(cds_line[2]),
                                               color = cds_line[1])
              }else{
                cds.layer <- geom_xsidesegment(data = sruc_cds_rg,
                                               aes(x = start,xend = end,y = group_id,yend = group_id),
                                               linewidth = as.numeric(cds_line[2]),
                                               color = cds_line[1])
              }

            }else{
              cds.layer <- NULL
            }

            # ==================================================================
            # PLOT
            # whether add new signal range
            if(new_signal_range == TRUE){
              axis.text.y = element_blank()
              axis.ticks.y = element_blank()

              range <- paste("[0-",round(max(pldf$rpm),digits = range_digit),"]",sep = "")

              if (requireNamespace("ggpp", quietly = TRUE)) {
                range_label <- ggpp::annotate(geom = "text_npc",
                                              npcx = range_x,npcy = range_y,
                                              label = range,
                                              size = range_size)
              } else {
                warning("Package 'ggpp' is needed for this function to work.")
              }

            }else{
              axis.text.y = NULL
              axis.ticks.y = NULL
              range_label <- NULL
            }

            # whether show merged sample and seperate sample together
            if(sep_mer_sample == TRUE){
              tmp.df2 <- pldf
              tmp.df2$sp <- "merged sample"

              pldf$sp <- pldf$sample
              pldf <- rbind(tmp.df2, pldf)

              facet_layer <- ggplot2::facet_grid(sp~rname,switch = "y")
            }

            # sample orders
            if(!is.null(sample_order)){
              if(sep_mer_sample == TRUE){
                tmp.df$sp <- factor(pldf$sp ,levels = c(sample_order,"merged sample"))
              }else{
                tmp.df$sample <- factor(pldf$sample ,levels = sample_order)
              }

            }

            # ==================================================================
            # plot
            # p <-
            ggplot(pldf) +
              player +
              range_label +
              # theme_bw() +
              facet_layer +
              theme(panel.grid = element_blank(),
                    axis.text = element_text(colour = "black"),
                    strip.text = element_text(colour = "black",size = rel(1)),
                    strip.text.x = element_text(face = "bold",colour = "black",size = rel(1)),
                    strip.background = element_blank(),
                    strip.placement = "outside",
                    strip.text.y.left = element_text(angle = 0,hjust = 1),
                    axis.text.y = axis.text.y,
                    axis.ticks.y = axis.ticks.y,
                    ggside.panel.scale.x = structure_panel_height,
                    ggside.panel.background = element_blank(),
                    ggside.panel.border = element_blank()) +
              # gene structure
              bg.layer + exon.layer + cds.layer +
              ggside::scale_xsidey_continuous(breaks = NULL,limits = sturc_limit) +
              xlab("Position along genome (nt)") +
              ylab(ylab) +
              ggside(collapse = "x") +
              col

          }
)

