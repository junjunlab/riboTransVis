# ==============================================================================
# visualization
# ==============================================================================

#' @title Visualize transcript signals
#'
#' @description Generic function definition for visualizing transcript-level signals, including ribosome occupancy and RNA-seq coverage.
#'
#' @param object The main object containing required data for visualization. Typically an S4 class object, such as `ribotrans`.
#' @param ... Additional parameters to be used in specific method implementations.
#'
#' @seealso \code{\link{trans_plot,ribotrans-method}} for the method implementation specific to the `ribotrans` class.
#' @export
#' @rdname trans_plot
setGeneric("trans_plot",function(object,...) standardGeneric("trans_plot"))



#' @title Plot transcript-based ribosome profiling and RNA-seq results
#'
#' @description Method implementation for `trans_plot`, specifically for objects of class `ribotrans`.
#'
#' @param object An S4 object of class `ribotrans`, containing ribosome profiling data, RNA-seq data, and gene annotation features.
#' @param selected_id A character vector of specific transcript IDs to plot. Defaults to \code{NULL}, where all transcripts associated with the gene are plotted.
#' @param type A character string specifying the type of plot to generate.
#'   Possible values are:
#'   \itemize{
#'     \item \code{"ribo"}: Ribosome footprint data.
#'     \item \code{"rna"}: RNA-seq data.
#'     \item \code{"ribo_rna"}: Ribosome occupancy normalized by RNA-seq (scaled by \code{scale_factor}).
#'     \item \code{"scaled_ribo"}: Scaled ribosome occupancy over RNA.
#'   }
#' @param layer A character string defining the plot layer. Options are:
#'   \itemize{
#'     \item \code{"line"}: Line plot.
#'     \item \code{"col"}: Bar (column) plot.
#'   }
#' @param sample_order The sample orders to be plotted.  Default: `NULL`.
#' @param facet_layer ggplot2 faceting specification, default facet_grid(sample~rname,switch = "y").
#' @param sep_mer_sample  Logical. Whether show samples separately and merged for different panels. Default: `FALSE`.
#' @param new_signal_range Logical. If `TRUE`, adds a signal range annotation to the plot. Default: `TRUE`.
#' @param range_x Numerics specifying the x position of the signal range annotation
#'   in normalized parent coordinates `[0, 1]`. Default: `0.9`.
#' @param range_y Numerics specifying the y position of the signal range annotation
#'   in normalized parent coordinates `[0, 1]`. Default: `0.9`.
#' @param range_size Numeric. Text size for the signal range label. Default: `4`.
#' @param range_digit Numeric. Number of decimal places for rounding signal range values. Default: `1`.
#' @param scale_factor Numeric, a scaling factor for RNA-seq reads when \code{type = "ribo_rna"} (default = 1.0).
#' @param utr_width Numeric, the line width for untranslated regions (UTRs) in the transcript structure (default = 1.0).
#' @param cds_width Numeric, the line width for coding sequences (CDS) in the transcript structure (default = 3.0).
#' @param utr_col Character, the color to use for UTR regions (default = "grey").
#' @param cds_col Character, the color to use for CDS regions (default = "grey30").
#' @param nrow Integer, the number of rows for arranging plots in a grid layout (default = \code{NULL}, auto-calculated).
#' @param ncol Integer, the number of columns for arranging plots in a grid layout (default = \code{NULL}, auto-calculated).
#'
#' @return A combined ggplot object or a plot grid as generated by `cowplot::plot_grid`, representing transcript plots with annotations.
#'
#' @details
#' This method facilitates visualizing transcript-level data from ribosome footprint profiling and RNA-seq analyses. The `type` parameter enables viewing raw ribosome or RNA data and scaled metrics. Annotations, such as UTR and CDS regions, are included for transcript-specific structural context.
#'
#' The plots are arranged in facets by sample and transcript ID, and plotting options (lines or bars) are easily customizable via the `layer` parameter.
#'
#' @seealso \code{\link{trans_plot}} for the generic function definition.
#' @import ggplot2
#' @importFrom ggside geom_xsidesegment scale_xsidey_continuous ggside
#' @importFrom cowplot plot_grid
#' @importFrom ggpp annotate
#' @export
#' @rdname trans_plot
setMethod("trans_plot",
          signature(object = "ribotrans"),
          function(object,
                   selected_id = NULL,
                   type = c("ribo","rna","ribo_rna","scaled_ribo"),
                   layer = c("line", "col"),
                   sample_order = NULL,
                   facet_layer = ggplot2::facet_grid(sample~rname,switch = "y"),
                   sep_mer_sample = FALSE,
                   new_signal_range = TRUE,
                   range_x = 0.9,
                   range_y = 0.9,
                   range_size = 4,
                   range_digit = 1,
                   scale_factor = 1,
                   utr_width = 1,
                   cds_width = 3,
                   utr_col = "grey",
                   cds_col = "grey30",
                   nrow = NULL,ncol = NULL){
            # check plot type
            type <- match.arg(type,choices = c("ribo","rna","ribo_rna","scaled_ribo"))
            layer <- match.arg(layer, choices = c("line", "col"))

            if(type == "ribo"){
              # check data
              if(nrow(object@ribo_occupancy) == 0){
                stop("Please run `get_occupancy` first!")
              }

              pldf <- object@ribo_occupancy
              ylab <- "Ribsome footprint occupancy"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- NULL
            }else if(type == "rna"){
              # check data
              if(nrow(object@RNA_coverage) == 0){
                stop("Please run `get_coverage` first!")
              }

              pldf <- object@RNA_coverage
              ylab <- "RNA reads coverage"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- NULL
            }else if(type == "ribo_rna"){
              ylab <- "Ribsome footprint occupancy \n (RNA reads coverage)"

              # check data
              if(nrow(object@scaled_occupancy) == 0){
                stop("Please run `get_scaled_occupancy` first!")
              }

              ribo <- object@ribo_occupancy
              ribo$exp <- "ribo"
              rna <- object@RNA_coverage
              rna$exp <- "rna"
              rna$smooth <- rna$smooth*scale_factor

              pldf <- rbind(ribo, rna)
              pldf$exp <- factor(pldf$exp,levels = c("rna","ribo"))

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = exp))
                col <- scale_color_manual(values = c("ribo" = "red", "rna" = "grey"))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = exp),width = 1)
                col <- scale_fill_manual(values = c("ribo" = "red", "rna" = "grey"))
              }

            }else if(type == "scaled_ribo"){
              ylab <- "Scaled ribosome footprint occupancy"

              pldf <- object@scaled_occupancy

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- NULL
            }


            # filter genes
            tanno <- object@features %>%
              dplyr::filter(gene == object@gene_name) %>%
              dplyr::mutate(rname = idnew)

            if(is.null(selected_id)){
              tids <- tanno$idnew
            }else{
              tids <- selected_id
            }

            # ==================================================================
            # loop plot for each transcript
            # x = 1
            lapply(seq_along(tids),function(x){
              tmp.df <- subset(pldf, rname == tids[x])
              tanno.tmp <- subset(tanno, rname == tids[x])

              # whether add new signal range
              if(new_signal_range == TRUE){
                axis.text.y = element_blank()
                axis.ticks.y = element_blank()

                range <- paste("[0-",round(max(tmp.df$smooth),digits = range_digit),"]",sep = "")

                range_label <- ggpp::annotate(geom = "text_npc",
                                              npcx = range_x,npcy = range_y,
                                              label = range,
                                              size = range_size)
              }else{
                axis.text.y = NULL
                axis.ticks.y = NULL
                range_label <- NULL
              }

              # whether show merged sample and seperate sample together
              if(sep_mer_sample == TRUE){
                tmp.df2 <- tmp.df
                tmp.df2$sp <- "merged sample"

                tmp.df$sp <- tmp.df$sample
                tmp.df <- rbind(tmp.df2, tmp.df)

                facet_layer <- ggplot2::facet_grid(sp~rname,switch = "y")
              }

              # sample orders
              if(!is.null(sample_order)){
                if(sep_mer_sample == TRUE){
                  tmp.df$sp <- factor(tmp.df$sp ,levels = c(sample_order,"merged sample"))
                }else{
                  tmp.df$sample <- factor(tmp.df$sample ,levels = sample_order)
                }

              }

              # plot
              p <-
                ggplot(tmp.df) +
                player +
                range_label +
                theme_bw() +
                # facet_wrap(~sample,scales = "fixed",ncol = 1,switch = "y") +
                facet_layer +
                theme(panel.grid = element_blank(),
                      axis.text = element_text(colour = "black"),
                      strip.text = element_text(colour = "black",size = rel(1)),
                      strip.text.x = element_text(face = "bold",colour = "black",size = rel(1)),
                      strip.background = element_blank(),
                      strip.placement = "outside",
                      strip.text.y.left = element_text(angle = 0,hjust = 1),
                      axis.text.y = axis.text.y,
                      axis.ticks.y = axis.ticks.y,
                      ggside.panel.background = element_blank(),
                      ggside.panel.border = element_blank()) +
                # gene structure
                geom_xsidesegment(data = tanno.tmp,aes(x = 0,xend = translen,y = 0.5,yend = 0.5),
                                  linewidth = utr_width,color = utr_col) +
                geom_xsidesegment(data = tanno.tmp,aes(x = mstart,xend = mstop,y = 0.5,yend = 0.5),
                                  linewidth = cds_width,color = cds_col) +
                ggside::scale_xsidey_continuous(breaks = NULL) +
                xlab("Position along transcript") +
                ylab(ylab) +
                ggside(collapse = "x") +
                col

              return(p)
            }) -> plist

            # combine plot list
            cowplot::plot_grid(plotlist = plist,nrow = nrow,ncol = ncol)

          }
)



# ==============================================================================
# function for length plot
# ==============================================================================

#' Generate Length Distribution Plot
#'
#' @description This generic function generates a length distribution plot for sequencing reads.
#'
#' @param object An object containing experimental data.
#' @param ... Additional arguments passed to class-specific methods.
#'
#' @return A ggplot object representing the length distribution of reads.
#'
#' @export
setGeneric("length_plot",function(object,...) standardGeneric("length_plot"))



#' @describeIn length_plot Generate a length distribution or frame-length plot for `ribotrans` objects.
#'
#' @description This method creates a plot showing read length distributions or read-frame distributions
#' for sequencing data stored in a `ribotrans` object.
#'
#' @param object A `ribotrans` object containing summary information.
#' @param return_data Whether return the data for plot, default `FALSE`.
#' @param type Character string specifying the plot type.
#' It must be one of the following:
#' \itemize{
#'   \item `"length"` - Produces a histogram of read lengths.
#'   \item `"frame_length"` - Produces a histogram of read lengths, colored by reading frame.
#' }
#'
#' @return A `ggplot2` object visualizing either the total read length distribution or frame-specific
#' read lengths.
#'
#' @details
#' - `"length"`: Groups reads by length (`qwidth`) and plots their total counts.
#' - `"frame_length"`: Groups reads by frame (`(pos - mstart) %% 3`) and colors them accordingly.
#'
#'
#' @importFrom ggplot2 ggplot geom_col scale_y_continuous facet_wrap
#' @importFrom ggplot2 theme element_text element_blank position_dodge2
#' @importFrom scales label_log
#' @importFrom fastplyr f_group_by f_summarise f_filter f_select
#'
#' @export
setMethod("length_plot",
          signature(object = "ribotrans"),
          function(object,
                   return_data = FALSE,
                   type = c("length","frame_length")){
            type <- match.arg(type, choices = c("length","frame_length"))

            # check plot type
            if(type == "length"){
              pltdf <- object@summary_info %>%
                fastplyr::f_group_by(sample, qwidth) %>%
                fastplyr::f_summarise(counts = sum(count))

              ptlayer <- geom_col(aes(x = qwidth, y = counts),width = 0.6,fill = "grey30")
              col <- NULL
            }else{
              pltdf <- object@summary_info %>%
                fastplyr::f_filter(mstart != 0 | mstop != 0) %>%
                dplyr::mutate(frame = (pos - mstart)%%3) %>%
                fastplyr::f_select(sample,qwidth,frame,count) %>%
                fastplyr::f_group_by(sample, qwidth, frame) %>%
                fastplyr::f_summarise(counts = sum(count))

              ptlayer <- geom_col(aes(x = qwidth, y = counts, fill = factor(frame)),
                                  width = 0.6, position = position_dodge2())

              col <- scale_fill_manual(values = c("0" = "#663366", "1" = "#996699", "2" = "#CC99CC"),
                                       name = "frame")
            }

            # plot
            p <-
            ggplot(pltdf) +
              ptlayer +
              col +
              theme(panel.grid = element_blank(),
                    strip.text = element_text(colour = "black",face = "bold",size = rel(1)),
                    axis.text = element_text(colour = "black")) +
              facet_wrap(~sample,scales = "free") +
              scale_y_continuous(labels = scales::label_log(base = 10,digits = 1)) +
              xlab("Read length (nt)") + ylab("Number of reads")

            # return
            if(return_data == FALSE){
              return(p)
            }else{
              return(pltdf)
            }
          }
)




# ==============================================================================
# function for relative distance plot
# ==============================================================================

#' Generate Relative Distance Plot
#'
#' @description This generic function generates a relative distance distribution plot for sequencing reads.
#'
#' @param object An object containing experimental data.
#' @param ... Additional arguments passed to class-specific methods.
#'
#' @return A `ggplot2` object representing the relative distance distribution of reads.
#'
#' @export
setGeneric("relative_dist_plot",function(object,...) standardGeneric("relative_dist_plot"))



#' @describeIn relative_dist_plot Generate a relative distance plot for `ribotrans` objects.
#'
#' @description This method generates a plot showing the relative distance of reads to either
#' the start codon or stop codon, grouped by frame.
#'
#' @param object A `ribotrans` object containing summary information.
#' @param return_data Whether return the data for plot, default `FALSE`.
#' @param type Character string specifying the plot type. Must be one of:
#' \itemize{
#'   \item `"rel2start"` - Relative to the start codon.
#'   \item `"rel2stop"` - Relative to the stop codon.
#' }
#' @param read_length Numeric vector of length two specifying the filter range for read length (default: `c(25,31)`).
#' @param rel2st_dist Numeric vector of length two specifying the relative distance range to the start codon (default: `c(-50,100)`).
#' @param rel2sp_dist Numeric vector of length two specifying the relative distance range to the stop codon (default: `c(-100,50)`).
#' @param facet_wrap A `ggh4x::facet_wrap2()` object for facetting by sample (default behavior).
#' @param facet_grid A `ggh4x::facet_grid2()` object for facetting by read length and sample.
#' @param collapse_readlength Logical, whether to collapse the visualization across all read lengths (`TRUE`) or show separate read lengths (`FALSE`, default).
#'
#' @return A `ggplot2` object visualizing the relative distribution to start/stop codons by frame.
#'
#' @details
#' - If `type = "rel2start"`, the distance is calculated as `pos - mstart` (relative to start codon).
#' - If `type = "rel2stop"`, the distance is calculated as `pos - mstop` (relative to stop codon).
#' - Filtering is applied based on `read_length`, `rel2st_dist`, and `rel2sp_dist`.
#' - The plot can either group data by read length (`collapse_readlength = FALSE`) or aggregate reads (`collapse_readlength = TRUE`).
#'
#' @examples
#' \dontrun{
#' # Generate relative plot with start codon distances
#' relative_dist_plot(ribo_obj, type = "rel2start")
#'
#' # Generate relative plot with stop codon distances
#' relative_dist_plot(ribo_obj, type = "rel2stop")
#' }
#'
#' @importFrom ggplot2 ggplot geom_col scale_fill_manual facet_wrap
#' @importFrom ggplot2 theme element_text element_blank position_dodge2
#' @importFrom scales label_log
#' @importFrom ggh4x facet_wrap2 facet_grid2
#' @importFrom fastplyr f_group_by f_summarise f_filter f_select
#' @importFrom dplyr mutate filter
#'
#' @export
setMethod("relative_dist_plot",
          signature(object = "ribotrans"),
          function(object,
                   return_data = FALSE,
                   type = c("rel2start","rel2stop"),
                   read_length = c(25,31),
                   rel2st_dist = c(-50,100),
                   rel2sp_dist = c(-100,50),
                   facet_wrap = ggh4x::facet_wrap2(~sample,scales = "free"),
                   facet_grid = ggh4x::facet_grid2(qwidth~sample,scales = "free", independent = "y"),
                   collapse_readlength = FALSE){
            type <- match.arg(type, choices = c("rel2start","rel2stop"))

            # extact data
            # check plot type
            if(type == "rel2start"){
              pltdf <- object@summary_info %>%
                fastplyr::f_filter(mstart != 0 | mstop != 0) %>%
                dplyr::mutate(frame = (pos - mstart)%%3,
                              rel = pos - mstart) %>%
                fastplyr::f_select(sample,qwidth,frame,rel,count)
            }else{
              pltdf <- object@summary_info %>%
                fastplyr::f_filter(mstart != 0 | mstop != 0) %>%
                dplyr::mutate(frame = (pos - mstart)%%3,
                              rel = pos - mstop) %>%
                fastplyr::f_select(sample,qwidth,frame,rel,count)
            }

            # filter length and distance
            if(type == "rel2start"){
              pltdf <- pltdf %>%
                dplyr::filter(qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
                dplyr::filter(rel >= rel2st_dist[1] & rel <= rel2st_dist[2])
            }else{
              pltdf <- pltdf %>%
                dplyr::filter(qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
                dplyr::filter(rel >= rel2sp_dist[1] & rel <= rel2sp_dist[2])
            }

            # check whether plot for each read length
            if(collapse_readlength == TRUE){
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample, rel, frame) %>%
                fastplyr::f_summarise(counts = sum(count))

              facetlayer <- facet_wrap
            }else{
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample,qwidth, rel, frame) %>%
                fastplyr::f_summarise(counts = sum(count))

              facetlayer <- facet_grid
            }


            # plot
            p <-
            ggplot(pltdf) +
              geom_col(aes(x = rel, y = counts, fill = factor(frame)),
                       width = 0.6, position = position_dodge2()) +
              theme(panel.grid = element_blank(),
                    strip.text = element_text(colour = "black",face = "bold",size = rel(1)),
                    axis.text = element_text(colour = "black")) +
              # facet_grid(qwidth~sample,scales = "free") +
              facetlayer +
              scale_y_continuous(labels = scales::label_log(base = 10,digits = 1)) +
              scale_fill_manual(values = c("0" = "#663366", "1" = "#996699", "2" = "#CC99CC"),
                                name ="frame") +
              xlab("Distance to start/stop codon (nt)") + ylab("Number of reads")

            # return
            if(return_data == FALSE){
              return(p)
            }else{
              return(pltdf)
            }
          }
)




# ==============================================================================
# function for metagene plot
# ==============================================================================

#' Generate Metagene Profile Plot
#'
#' @description A generic function to generate a metagene profile plot
#' visualizing read distributions relative to start or stop codons.
#'
#' @param object An object containing sequencing data.
#' @param ... Additional arguments passed to specific methods.
#'
#' @return A `ggplot2` object showing the metagene profile distribution.
#'
#' @export
setGeneric("metagene_plot",function(object,...) standardGeneric("metagene_plot"))



#' @describeIn metagene_plot Generate a metagene profile plot for `ribotrans` objects.
#'
#' @description This method creates a metagene profile plot showing the
#' distribution of ribosome-protected fragments (RPFs) relative to the
#' start or stop codon.
#'
#' @param object A `ribotrans` object containing RNA sequencing metrics.
#' @param type Character string specifying the metagene type. Must be one of:
#' \itemize{
#'   \item `"rel2start"` - Distance relative to the start codon.
#'   \item `"rel2stop"` - Distance relative to the stop codon.
#' }
#' @param smooth Logical indicating if a rolling average should be applied to smooth the data (default: `FALSE`).
#' @param return_data Logical, if `TRUE`, returns the processed data instead of a plot (default: `FALSE`).
#' @param show_frame Logical, if `TRUE`, visualizes data by reading frame (default: `FALSE`).
#' @param read_length Numeric vector of length two specifying the range of read lengths to include (default: `c(25,31)`).
#' @param slide_window Integer defining the sliding window size for smoothing when `smooth = TRUE` (default: `3`).
#' @param rel2st_dist Numeric vector of length two, specifying distance range to include relative to start codon (default: `c(-50,100)`).
#' @param rel2sp_dist Numeric vector of length two, specifying distance range to include relative to stop codon (default: `c(-100,50)`).
#' @param facet_wrap A `ggplot2::facet_wrap()` object to control faceting by sample (default behavior).
#'
#' @return If `return_data = FALSE`, returns a `ggplot2` object showing the metagene profile plot.
#' If `return_data = TRUE`, returns a processed `data.frame` containing metagene read distributions.
#'
#' @details
#' - The function normalizes read counts based on total mapped reads (RPM normalization).
#' - Optionally, it applies a rolling average (`slide_window`) to smooth the profile.
#' - If `show_frame = TRUE`, colors are applied for individual reading frames.
#'
#' @examples
#' \dontrun{
#' # Generate standard metagene plot relative to start codon
#' metagene_plot(ribo_obj, type = "rel2start")
#'
#' # Generate smoothed metagene plot
#' metagene_plot(ribo_obj, type = "rel2stop", smooth = TRUE, slide_window = 3)
#'
#' # Get the underlying data instead of a plot
#' data <- metagene_plot(ribo_obj, type = "rel2start", return_data = TRUE)
#' head(data)
#' }
#'
#' @importFrom ggplot2 ggplot geom_line scale_color_manual facet_wrap
#' @importFrom ggplot2 theme element_text element_blank
#' @importFrom dplyr mutate filter left_join select summarise
#' @importFrom fastplyr f_group_by f_summarise f_filter f_select f_left_join
#' @importFrom zoo rollmean
#' @importFrom purrr map_df
#'
#' @export
setMethod("metagene_plot",
          signature(object = "ribotrans"),
          function(object,
                   type = c("rel2start","rel2stop"),
                   smooth = FALSE,
                   return_data = FALSE,
                   show_frame = FALSE,
                   read_length = c(25,31),
                   slide_window = 3,
                   rel2st_dist = c(-50,100),
                   rel2sp_dist = c(-100,50),
                   facet_wrap = ggplot2::facet_wrap(~sample)){
            type <- match.arg(type, choices = c("rel2start","rel2stop"))

            features <- object@features

            pltdf <- object@summary_info %>%
              fastplyr::f_filter(mstart != 0 | mstop != 0,
                                 qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
              fastplyr::f_group_by(sample,rname, pos) %>%
              fastplyr::f_summarise(counts = sum(count))

            # get total mapped reads
            lib <- object@library
            dpt <- subset(lib, type == "ribo" & sample %in% unique(pltdf$sample)) %>%
              dplyr::select(mappped_reads,sample)

            # rpm normalization
            pltdf <- pltdf %>%
              dplyr::left_join(y = dpt,by = "sample") %>%
              dplyr::mutate(rpm = (counts/mappped_reads)*10^6) %>%
              dplyr::select(-mappped_reads)

            # total transcipts
            ttt <- length(unique(pltdf$rname))

            pltdf <- pltdf %>%
              fastplyr::f_left_join(y = features[,c("idnew","mstart","mstop")],
                                    by = c("rname" = "idnew"))


            # calculate frame and relative distance
            if(type == "rel2start"){
              pltdf <- pltdf %>%
                dplyr::mutate(frame = (pos - mstart)%%3,
                              rel = pos - mstart) %>%
                fastplyr::f_select(sample,frame,pos,rel,rpm)
            }else{
              pltdf <- pltdf %>%
                dplyr::mutate(frame = (pos - mstop)%%3,
                              rel = pos - mstop) %>%
                fastplyr::f_select(sample,frame,pos,rel,rpm)
            }


            # check whether plot for each read length
            if(show_frame == TRUE){
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample,rel,frame) %>%
                fastplyr::f_summarise(normval = sum(rpm)/ttt)

              pltlayer <- geom_line(aes(x = rel, y = relexp, color = factor(frame)))
              col <- scale_color_manual(values = c("0" = "#663366", "1" = "#996699", "2" = "#CC99CC"),
                                        name ="frame")
            }else{
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample,rel) %>%
                fastplyr::f_summarise(normval = sum(rpm)/ttt)

              pltlayer <- geom_line(aes(x = rel, y = relexp))
              col <- NULL
            }


            # filter length and distance
            if(type == "rel2start"){
              pltdf <- pltdf %>%
                dplyr::filter(rel >= rel2st_dist[1] & rel <= rel2st_dist[2])

              distrg <- seq(rel2st_dist[1],rel2st_dist[2],1)
            }else{
              pltdf <- pltdf %>%
                dplyr::filter(rel >= rel2sp_dist[1] & rel <= rel2sp_dist[2])

              distrg <- seq(rel2sp_dist[1],rel2sp_dist[2],1)
            }

            # ==================================================================
            # whether smooth data
            if(smooth == TRUE){
              sp <- unique(pltdf$sample)

              # x = 1
              purrr::map_df(seq_along(sp),function(x){
                tmp <- subset(pltdf, sample == sp[x])

                tmp2 <- data.frame(sample = sp[x],rel = distrg)
                tmp2 <- tmp2 %>%
                  dplyr::left_join(y = tmp,by = c("sample","rel"))

                tmp2$smooth <- zoo::rollmean(tmp2$normval, k = slide_window, fill = 0)

                return(tmp2)
              })-> sm.df
            }else{
              sm.df <- pltdf %>%
                dplyr::mutate(smooth = normval)

            }


            ave.tmp <- sm.df %>%
              dplyr::group_by(sample) %>%
              dplyr::summarise(allexp = sum(normval)) %>%
              dplyr::mutate(ave = allexp/length(distrg)) %>%
              dplyr::select(sample, ave)

            sm.df <- sm.df %>%
              dplyr::left_join(y = ave.tmp,by = "sample") %>%
              dplyr::mutate(relexp = normval/ave)

            # plot
            p <-
              ggplot(sm.df) +
              pltlayer +
              theme(panel.grid = element_blank(),
                    strip.text = element_text(colour = "black",face = "bold",size = rel(1)),
                    axis.text = element_text(colour = "black")) +
              # facet_wrap(~sample) +
              facet_wrap +
              col +
              xlab("Distance to start/stop codon (nt)") + ylab("Normalized reads")


            # return
            if(return_data == FALSE){
              return(p)
            }else{
              return(sm.df)
            }

          }
)
