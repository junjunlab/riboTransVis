# ==============================================================================
# visualization
# ==============================================================================


#' @title Visualize transcript signals
#'
#' @description Generic function definition for visualizing transcript-level signals, including ribosome occupancy and RNA-seq coverage.
#'
#' @param object The main object containing required data for visualization. Typically an S4 class object, such as `ribotrans`.
#' @param ... Additional parameters to be used in specific method implementations.
#'
#' @seealso \code{\link{trans_plot,ribotrans-method}} for the method implementation specific to the `ribotrans` class.
#' @export
#' @rdname trans_plot
setGeneric("trans_plot",function(object,...) standardGeneric("trans_plot"))



#' @title Plot transcript-based ribosome profiling and RNA-seq results
#'
#' @description Method implementation for `trans_plot`, specifically for objects of class `ribotrans`.
#'
#' @param object An S4 object of class `ribotrans`, containing ribosome profiling data, RNA-seq data, and gene annotation features.
#' @param selected_id A character vector of specific transcript IDs to plot. Defaults to \code{NULL}, where all transcripts associated with the gene are plotted.
#' @param type A character string specifying the type of plot to generate.
#'   Possible values are:
#'   \itemize{
#'     \item \code{"ribo"}: Ribosome footprint data.
#'     \item \code{"rna"}: RNA-seq data.
#'     \item \code{"ribo_rna"}: Ribosome occupancy normalized by RNA-seq (scaled by \code{scale_factor}).
#'     \item \code{"scaled_ribo"}: Scaled ribosome occupancy over RNA.
#'   }
#' @param layer A character string defining the plot layer. Options are:
#'   \itemize{
#'     \item \code{"line"}: Line plot.
#'     \item \code{"col"}: Bar (column) plot.
#'   }
#' @param sample_order The sample orders to be plotted.  Default: `NULL`.
#' @param facet_layer ggplot2 faceting specification, default facet_grid(sample~rname,switch = "y").
#' @param sep_mer_sample  Logical. Whether show samples separately and merged for different panels. Default: `FALSE`.
#' @param new_signal_range Logical. If `TRUE`, adds a signal range annotation to the plot. Default: `TRUE`.
#' @param position_mode Character, position display mode. One of:
#'   * "nt": nucleotide positions
#'   * "codon": codon positions.
#' @param range_x Numerics specifying the x position of the signal range annotation
#'   in normalized parent coordinates `[0, 1]`. Default: `0.9`.
#' @param range_y Numerics specifying the y position of the signal range annotation
#'   in normalized parent coordinates `[0, 1]`. Default: `0.9`.
#' @param range_size Numeric. Text size for the signal range label. Default: `4`.
#' @param range_digit Numeric. Number of decimal places for rounding signal range values. Default: `1`.
#' @param scale_factor Numeric, a scaling factor for RNA-seq reads when \code{type = "ribo_rna"} (default = 1.0).
#' @param utr_width Numeric, the line width for untranslated regions (UTRs) in the transcript structure (default = 1.0).
#' @param cds_width Numeric, the line width for coding sequences (CDS) in the transcript structure (default = 3.0).
#' @param utr_col Character, the color to use for UTR regions (default = "grey").
#' @param cds_col Character, the color to use for CDS regions (default = "grey30").
#' @param nrow Integer, the number of rows for arranging plots in a grid layout (default = \code{NULL}, auto-calculated).
#' @param ncol Integer, the number of columns for arranging plots in a grid layout (default = \code{NULL}, auto-calculated).
#'
#' @return A combined ggplot object or a plot grid as generated by `cowplot::plot_grid`, representing transcript plots with annotations.
#'
#' @details
#' This method facilitates visualizing transcript-level data from ribosome footprint profiling and RNA-seq analyses. The `type` parameter enables viewing raw ribosome or RNA data and scaled metrics. Annotations, such as UTR and CDS regions, are included for transcript-specific structural context.
#'
#' The plots are arranged in facets by sample and transcript ID, and plotting options (lines or bars) are easily customizable via the `layer` parameter.
#'
#' @seealso \code{\link{trans_plot}} for the generic function definition.
#'
#' @examples
#' \dontrun{
#' # Plot ribosome footprint occupancy
#' trans_plot(ribo_obj, type = "ribo")
#'
#' # Plot RNA coverage with custom sample order
#' trans_plot(ribo_obj, type = "rna",
#'           sample_order = c("Sample1", "Sample2"))
#'
#' # Plot combined ribo-RNA view in codon mode
#' trans_plot(ribo_obj, type = "ribo_rna",
#'           position_mode = "codon")
#' }
#'
#' @import ggplot2
#' @importFrom ggside geom_xsidesegment scale_xsidey_continuous ggside
#' @export
#' @rdname trans_plot
setMethod("trans_plot",
          signature(object = "ribotrans"),
          function(object,
                   selected_id = NULL,
                   type = c("ribo","rna","ribo_rna","scaled_ribo"),
                   layer = c("line", "col"),
                   sample_order = NULL,
                   facet_layer = ggplot2::facet_grid(sample~rname,switch = "y"),
                   sep_mer_sample = FALSE,
                   new_signal_range = TRUE,
                   position_mode = c("nt", "codon"),
                   range_x = 0.9,
                   range_y = 0.9,
                   range_size = 4,
                   range_digit = 1,
                   scale_factor = 1,
                   utr_width = 1,
                   cds_width = 3,
                   utr_col = "grey",
                   cds_col = "grey30",
                   nrow = NULL,ncol = NULL){
            # check plot type
            type <- match.arg(type,choices = c("ribo","rna","ribo_rna","scaled_ribo"))
            layer <- match.arg(layer, choices = c("line", "col"))
            position_mode <- match.arg(position_mode, choices = c("nt", "codon"))

            if(type == "ribo"){
              # check data
              if(nrow(object@ribo_occupancy) == 0){
                stop("Please run `get_occupancy` first!")
              }

              pldf <- object@ribo_occupancy
              ylab <- "Ribsome footprint occupancy (RPM)"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- NULL
            }else if(type == "rna"){
              # check data
              if(nrow(object@RNA_coverage) == 0){
                stop("Please run `get_coverage` first!")
              }

              pldf <- object@RNA_coverage
              ylab <- "RNA reads coverage (RPM)"

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- NULL
            }else if(type == "ribo_rna"){
              ylab <- "Ribsome footprint occupancy \n (RNA reads coverage)"

              # check data
              if(nrow(object@ribo_occupancy) == 0){
                stop("Please run `get_occupancy` first!")
              }

              # check data
              if(nrow(object@RNA_coverage) == 0){
                stop("Please run `get_coverage` first!")
              }

              ribo <- object@ribo_occupancy
              ribo$exp <- "ribo"
              rna <- object@RNA_coverage
              rna$exp <- "rna"
              rna$smooth <- rna$smooth*scale_factor

              pldf <- rbind(ribo, rna)
              pldf$exp <- factor(pldf$exp,levels = c("rna","ribo"))

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = exp))
                col <- scale_color_manual(values = c("ribo" = "red", "rna" = "grey"))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = exp),width = 1)
                col <- scale_fill_manual(values = c("ribo" = "red", "rna" = "grey"))
              }

            }else if(type == "scaled_ribo"){
              ylab <- "Scaled ribosome footprint occupancy"

              # check data
              if(nrow(object@scaled_occupancy) == 0){
                stop("Please run `get_scaled_occupancy` first!")
              }


              pldf <- object@scaled_occupancy

              if(layer == "line"){
                player <- geom_path(aes(x = pos,y = smooth,color = sample))
              }else{
                player <- geom_col(aes(x = pos,y = smooth,fill = sample),width = 1)
              }

              col <- NULL
            }


            # filter genes
            tanno <- object@features %>%
              dplyr::filter(gene == object@gene_name) %>%
              dplyr::mutate(rname = idnew)

            if(is.null(selected_id)){
              tids <- tanno$idnew
            }else{
              tids <- selected_id
            }

            # ==================================================================
            # loop plot for each transcript
            # x = 1
            lapply(seq_along(tids),function(x){
              tmp.df <- subset(pldf, rname == tids[x])
              tanno.tmp <- subset(tanno, rname == tids[x])

              # check position_mode
              if(position_mode == "codon"){
                tmp.df <- tmp.df %>%
                  dplyr::filter(pos >= tanno.tmp$mstart & pos <= tanno.tmp$mstop) %>%
                  dplyr::mutate(pos = pos - tanno.tmp$mstart + 1) %>%
                  dplyr::mutate(codon = (pos - 1) %/% 3 + 1) %>%
                  dplyr::group_by(sample,rname,codon) %>%
                  dplyr::summarise(smooth = mean(smooth)) %>%
                  dplyr::rename(pos = codon)

                xlab <- "Position along transcript (codon/AA)"

                struc_layer1 <-
                  geom_xsidesegment(data = tanno.tmp,
                                    aes(x = 1,xend = tanno.tmp$cds/3,y = 0.5,yend = 0.5),
                                    linewidth = cds_width,color = cds_col)
                struc_layer2 <- NULL
              }else{
                xlab <- "Position along transcript (nt)"

                struc_layer1 <-
                  geom_xsidesegment(data = tanno.tmp,
                                    aes(x = 1,xend = translen,y = 0.5,yend = 0.5),
                                    linewidth = utr_width,color = utr_col)
                struc_layer2 <-
                  geom_xsidesegment(data = tanno.tmp,
                                    aes(x = mstart,xend = mstop,y = 0.5,yend = 0.5),
                                    linewidth = cds_width,color = cds_col)
              }

              # whether add new signal range
              if(new_signal_range == TRUE){
                axis.text.y = element_blank()
                axis.ticks.y = element_blank()

                range <- paste("[0-",round(max(tmp.df$smooth),digits = range_digit),"]",sep = "")

                if (requireNamespace("ggpp", quietly = TRUE)) {
                  range_label <- ggpp::annotate(geom = "text_npc",
                                                npcx = range_x,npcy = range_y,
                                                label = range,
                                                size = range_size)
                } else {
                  warning("Package 'ggpp' is needed for this function to work.")
                }

              }else{
                axis.text.y = NULL
                axis.ticks.y = NULL
                range_label <- NULL
              }

              # whether show merged sample and seperate sample together
              if(sep_mer_sample == TRUE){
                tmp.df2 <- tmp.df
                tmp.df2$sp <- "merged sample"

                tmp.df$sp <- tmp.df$sample
                tmp.df <- rbind(tmp.df2, tmp.df)

                facet_layer <- ggplot2::facet_grid(sp~rname,switch = "y")
              }

              # sample orders
              if(!is.null(sample_order)){
                if(sep_mer_sample == TRUE){
                  tmp.df$sp <- factor(tmp.df$sp ,levels = c(sample_order,"merged sample"))
                }else{
                  tmp.df$sample <- factor(tmp.df$sample ,levels = sample_order)
                }

              }

              # plot
              p <-
                ggplot(tmp.df) +
                player +
                range_label +
                theme_bw() +
                # facet_wrap(~sample,scales = "fixed",ncol = 1,switch = "y") +
                facet_layer +
                theme(panel.grid = element_blank(),
                      axis.text = element_text(colour = "black"),
                      strip.text = element_text(colour = "black",size = rel(1)),
                      strip.text.x = element_text(face = "bold",colour = "black",size = rel(1)),
                      strip.background = element_blank(),
                      strip.placement = "outside",
                      strip.text.y.left = element_text(angle = 0,hjust = 1),
                      axis.text.y = axis.text.y,
                      axis.ticks.y = axis.ticks.y,
                      ggside.panel.background = element_blank(),
                      ggside.panel.border = element_blank()) +
                # gene structure
                struc_layer1 + struc_layer2 +
                ggside::scale_xsidey_continuous(breaks = NULL) +
                xlab(xlab) +
                ylab(ylab) +
                ggside(collapse = "x") +
                col

              return(p)
            }) -> plist

            # combine plot list
            if (requireNamespace("cowplot", quietly = TRUE)) {
              cowplot::plot_grid(plotlist = plist,nrow = nrow,ncol = ncol)
            } else {
              warning("Package 'cowplot' is needed for this function to work.")
            }


          }
)



# ==============================================================================
# function for length plot
# ==============================================================================

#' Generate Length Distribution Plot
#'
#' @description This generic function generates a length distribution plot for sequencing reads.
#'
#' @param object An object containing experimental data.
#' @param ... Additional arguments passed to class-specific methods.
#'
#' @return A ggplot object representing the length distribution of reads.
#'
#' @export
setGeneric("length_plot",function(object,...) standardGeneric("length_plot"))



#' @describeIn length_plot Generate a length distribution or frame-length plot for `ribotrans` objects.
#'
#' @description This method creates a plot showing read length distributions or read-frame distributions
#' for sequencing data stored in a `ribotrans` object.
#'
#' @param object A `ribotrans` object containing summary information.
#' @param return_data Whether return the data for plot, default `FALSE`.
#' @param type Character string specifying the plot type.
#' It must be one of the following:
#' \itemize{
#'   \item `"length"` - Produces a histogram of read lengths.
#'   \item `"frame_length"` - Produces a histogram of read lengths, colored by reading frame.
#' }
#'
#' @return A `ggplot2` object visualizing either the total read length distribution or frame-specific
#' read lengths.
#'
#' @details
#' - `"length"`: Groups reads by length (`qwidth`) and plots their total counts.
#' - `"frame_length"`: Groups reads by frame (`(pos - mstart) %% 3`) and colors them accordingly.
#'
#'
#' @importFrom ggplot2 ggplot geom_col scale_y_continuous facet_wrap
#' @importFrom ggplot2 theme element_text element_blank position_dodge2
#' @importFrom scales label_log
#' @importFrom fastplyr f_group_by f_summarise f_filter f_select
#'
#' @export
setMethod("length_plot",
          signature(object = "ribotrans"),
          function(object,
                   return_data = FALSE,
                   type = c("length","frame_length")){
            type <- match.arg(type, choices = c("length","frame_length"))

            # check plot type
            if(type == "length"){
              pltdf <- object@summary_info %>%
                fastplyr::f_group_by(sample, qwidth) %>%
                fastplyr::f_summarise(counts = sum(count))

              ptlayer <- geom_col(aes(x = qwidth, y = counts),width = 0.6,fill = "grey30")
              col <- NULL
            }else{
              pltdf <- object@summary_info %>%
                fastplyr::f_filter(mstart != 0 | mstop != 0) %>%
                dplyr::mutate(frame = (pos - mstart)%%3) %>%
                fastplyr::f_select(sample,qwidth,frame,count) %>%
                fastplyr::f_group_by(sample, qwidth, frame) %>%
                fastplyr::f_summarise(counts = sum(count))

              ptlayer <- geom_col(aes(x = qwidth, y = counts, fill = factor(frame)),
                                  width = 0.6, position = position_dodge2())

              col <- scale_fill_manual(values = c("0" = "#663366", "1" = "#996699", "2" = "#CC99CC"),
                                       name = "frame")
            }

            # plot
            p <-
              ggplot(pltdf) +
              ptlayer +
              col +
              theme(panel.grid = element_blank(),
                    strip.text = element_text(colour = "black",face = "bold",size = rel(1)),
                    axis.text = element_text(colour = "black")) +
              facet_wrap(~sample,scales = "free") +
              scale_y_continuous(labels = scales::label_log(base = 10,digits = 1)) +
              xlab("Read length (nt)") + ylab("Number of reads")

            # return
            if(return_data == FALSE){
              return(p)
            }else{
              return(pltdf)
            }
          }
)




# ==============================================================================
# function for relative distance plot
# ==============================================================================

#' Generate Relative Distance Plot
#'
#' @description This generic function generates a relative distance distribution plot for sequencing reads.
#'
#' @param object An object containing experimental data.
#' @param ... Additional arguments passed to class-specific methods.
#'
#' @return A `ggplot2` object representing the relative distance distribution of reads.
#'
#' @export
setGeneric("relative_dist_plot",function(object,...) standardGeneric("relative_dist_plot"))



#' @describeIn relative_dist_plot Generate a relative distance plot for `ribotrans` objects.
#'
#' @description This method generates a plot showing the relative distance of reads to either
#' the start codon or stop codon, grouped by frame.
#'
#' @param object A `ribotrans` object containing summary information.
#' @param return_data Whether return the data for plot, default `FALSE`.
#' @param type Character string specifying the plot type. Must be one of:
#' \itemize{
#'   \item `"rel2start"` - Relative to the start codon.
#'   \item `"rel2stop"` - Relative to the stop codon.
#' }
#' @param read_length Numeric vector of length two specifying the filter range for read length (default: `c(25,31)`).
#' @param rel2st_dist Numeric vector of length two specifying the relative distance range to the start codon (default: `c(-50,100)`).
#' @param rel2sp_dist Numeric vector of length two specifying the relative distance range to the stop codon (default: `c(-100,50)`).
#' @param facet_wrap A `ggh4x::facet_wrap2()` object for facetting by sample (default behavior).
#' @param facet_grid A `ggh4x::facet_grid2()` object for facetting by read length and sample.
#' @param collapse_readlength Logical, whether to collapse the visualization across all read lengths (`TRUE`) or show separate read lengths (`FALSE`, default).
#'
#' @return A `ggplot2` object visualizing the relative distribution to start/stop codons by frame.
#'
#' @details
#' - If `type = "rel2start"`, the distance is calculated as `pos - mstart` (relative to start codon).
#' - If `type = "rel2stop"`, the distance is calculated as `pos - mstop` (relative to stop codon).
#' - Filtering is applied based on `read_length`, `rel2st_dist`, and `rel2sp_dist`.
#' - The plot can either group data by read length (`collapse_readlength = FALSE`) or aggregate reads (`collapse_readlength = TRUE`).
#'
#' @examples
#' \dontrun{
#' # Generate relative plot with start codon distances
#' relative_dist_plot(ribo_obj, type = "rel2start")
#'
#' # Generate relative plot with stop codon distances
#' relative_dist_plot(ribo_obj, type = "rel2stop")
#' }
#'
#' @importFrom ggplot2 ggplot geom_col scale_fill_manual facet_wrap
#' @importFrom ggplot2 theme element_text element_blank position_dodge2
#' @importFrom scales label_log
#' @importFrom ggh4x facet_wrap2 facet_grid2
#' @importFrom fastplyr f_group_by f_summarise f_filter f_select
#' @importFrom dplyr mutate filter
#'
#' @export
setMethod("relative_dist_plot",
          signature(object = "ribotrans"),
          function(object,
                   return_data = FALSE,
                   type = c("rel2start","rel2stop"),
                   read_length = c(25,31),
                   rel2st_dist = c(-50,100),
                   rel2sp_dist = c(-100,50),
                   facet_wrap = ggh4x::facet_wrap2(~sample,scales = "free"),
                   facet_grid = ggh4x::facet_grid2(qwidth~sample,scales = "free", independent = "y"),
                   collapse_readlength = FALSE){
            type <- match.arg(type, choices = c("rel2start","rel2stop"))

            # extact data
            # check plot type
            if(type == "rel2start"){
              pltdf <- object@summary_info %>%
                fastplyr::f_filter(mstart != 0 | mstop != 0) %>%
                dplyr::mutate(frame = (pos - mstart)%%3,
                              rel = pos - mstart) %>%
                fastplyr::f_select(sample,qwidth,frame,rel,count)
            }else{
              pltdf <- object@summary_info %>%
                fastplyr::f_filter(mstart != 0 | mstop != 0) %>%
                dplyr::mutate(frame = (pos - mstart)%%3,
                              rel = pos - mstop) %>%
                fastplyr::f_select(sample,qwidth,frame,rel,count)
            }

            # filter length and distance
            if(type == "rel2start"){
              pltdf <- pltdf %>%
                dplyr::filter(qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
                dplyr::filter(rel >= rel2st_dist[1] & rel <= rel2st_dist[2])
            }else{
              pltdf <- pltdf %>%
                dplyr::filter(qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
                dplyr::filter(rel >= rel2sp_dist[1] & rel <= rel2sp_dist[2])
            }

            # check whether plot for each read length
            if(collapse_readlength == TRUE){
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample, rel, frame) %>%
                fastplyr::f_summarise(counts = sum(count))

              facetlayer <- facet_wrap
            }else{
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample,qwidth, rel, frame) %>%
                fastplyr::f_summarise(counts = sum(count))

              facetlayer <- facet_grid
            }


            # plot
            p <-
              ggplot(pltdf) +
              geom_col(aes(x = rel, y = counts, fill = factor(frame)),
                       width = 0.6, position = position_dodge2()) +
              theme(panel.grid = element_blank(),
                    strip.text = element_text(colour = "black",face = "bold",size = rel(1)),
                    axis.text = element_text(colour = "black")) +
              # facet_grid(qwidth~sample,scales = "free") +
              facetlayer +
              scale_y_continuous(labels = scales::label_log(base = 10,digits = 1)) +
              scale_fill_manual(values = c("0" = "#663366", "1" = "#996699", "2" = "#CC99CC"),
                                name ="frame") +
              xlab("Distance to start/stop codon (nt)") + ylab("Number of reads")

            # return
            if(return_data == FALSE){
              return(p)
            }else{
              return(pltdf)
            }
          }
)



# ==============================================================================
# function for relative heatmap plot
# ==============================================================================

#' Relative Heatmap Plot Generic Function
#'
#' @description This is a generic function for creating relative heatmap plots
#' across different data objects.
#'
#' @param object An object that contains the necessary data for plotting.
#' @param ... Additional arguments passed to specific methods.
#'
#' @return A heatmap plot specific to the method invoked.
#'
#' @export
#' @rdname relative_heatmap_plot
setGeneric("relative_heatmap_plot",function(object,...) standardGeneric("relative_heatmap_plot"))



#' Generate a Relative Heatmap Plot
#'
#' @description This function creates a heatmap that represents the relative position
#' of reads with respect to either start or stop codons of genes.
#'
#'
#' @param object An object of class \code{ribotrans}, containing summary information from ribosome profiling data.
#' @param type A character string indicating the type of plot. Options are:
#'  \code{"rel2start"} to plot relative to start codon or
#'  \code{"rel2stop"} to plot relative to stop codon. Default is \code{"rel2start"}.
#' @param read_length A numeric vector of length 2 specifying the range of read lengths to include in the plot. Default is \code{c(20, 35)}.
#' @param rel_dist A numeric vector of length 2 specifying the range of relative distances to plot. Default is \code{c(-100, 100)}.
#' @param log_scale A logical value indicating whether to apply a logarithmic transformation to counts. Default is \code{FALSE}.
#' @param return_data A logical value determining the return type. If \code{TRUE}, the summarized data is returned; if \code{FALSE}, the plot object is returned. Default is \code{FALSE}.
#'
#' @return A ggplot object if \code{return_data} is \code{FALSE}, otherwise a data.table with summarized counts and relevant metadata.
#'
#' @details
#' The function checks whether the summary information is available in the provided
#' \code{ribotrans} object and filters data based on the specified criteria.
#' The resulting heatmap visualizes the distribution of read counts along with
#' their relative positions to the coding features.
#'
#' @import ggplot2
#' @importFrom dplyr mutate filter group_by summarise
#' @importFrom fastplyr f_filter f_group_by f_summarise
#'
#'
#' @export
#' @rdname relative_heatmap_plot
setMethod("relative_heatmap_plot",
          signature(object = "ribotrans"),
          function(object,
                   type = c("rel2start","rel2stop"),
                   read_length = c(20,35),
                   rel_dist = c(-100,100),
                   log_scale = FALSE,
                   return_data = FALSE){

            type <- match.arg(type,choices = c("rel2start","rel2stop"))

            # check data
            if(nrow(object@summary_info) == 0){
              stop("Please run `generate_summary` first!")
            }

            # extarct data to plot
            if(type == "rel2start"){
              summary.info <- object@summary_info %>%
                fastplyr::f_filter(mstart > 0 & mstop > 0) %>%
                dplyr::mutate(rel_pos = pos - mstart)

              xlab <- "Distance to start codon (nt)"
            }else{
              summary.info <- object@summary_info %>%
                fastplyr::f_filter(mstart > 0 & mstop > 0) %>%
                dplyr::mutate(rel_pos = pos - mstop)

              xlab <- "Distance to stop codon (nt)"
            }

            # filter data
            summary.info <- summary.info %>%
              fastplyr::f_filter(rel_pos >= rel_dist[1] & rel_pos <= rel_dist[2]) %>%
              fastplyr::f_filter(qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
              fastplyr::f_group_by(sample, rel_pos, qwidth) %>%
              fastplyr::f_summarise(counts = sum(count))

            # check log_scale
            if(log_scale == TRUE){
              layer <- geom_tile(aes(x = rel_pos,y = qwidth, fill = log2(counts)))
            }else{
              layer <- geom_tile(aes(x = rel_pos,y = qwidth, fill = counts))
            }

            # plot
            p <-
              ggplot(summary.info) +
              layer +
              facet_wrap(~sample,scales = "free") +
              theme(axis.text = element_text(colour = "black"),
                    panel.grid = element_blank(),
                    strip.text = element_text(colour = "black",size = rel(1),face = "bold")) +
              scale_fill_viridis_c(option = "mako") +
              xlab(xlab) +
              ylab("Reads length (nt)")


            # check return type
            if(return_data == FALSE){
              return(p)
            }else{
              return(summary.info)
            }

          }
)




# ==============================================================================
# function for reads offset check plot
# ==============================================================================
#' @title Generic function for plotting relative offset in ribosome profiling data
#'
#' @description This generic function is used to plot the relative offset of reads
#' in ribosome profiling data.
#'
#' @param object An object of class \code{ribotrans}.
#' @param ... Additional arguments passed to specific methods.
#'
#' @return A plot showing the relative offset of reads.
#'
#' @seealso \code{\link{relative_offset_plot,ribotrans-method}}
#'
#' @export
#' @rdname relative_offset_plot
setGeneric("relative_offset_plot",function(object,...) standardGeneric("relative_offset_plot"))



#' @title Plot relative offset distribution in ribosome profiling data
#'
#' @description This method generates a plot of relative offsets of ribosome profiling
#' reads mapped to either the start or stop codon.
#'
#' @param object A \code{ribotrans} object containing ribosome profiling data.
#' @param type Character string specifying the reference point: \code{"rel2start"} for
#' start codon or \code{"rel2stop"} for stop codon. Default is \code{"rel2start"}.
#' @param read_length A numeric vector of length two specifying the range of read
#' lengths to include (default: \code{c(20, 35)}).
#' @param rel_dist A numeric vector of length two specifying the relative distance
#' range to include (default: \code{c(-30, 30)}).
#' @param rm_yaxis_label Logical; if \code{TRUE}, removes y-axis labels (default: \code{TRUE}).
#' @param max_offset_labelx Numeric value (between 0 and 1) specifying the x position
#' of the label showing the most frequent offset (default: \code{0.9}).
#' @param max_offset_labely Numeric value (between 0 and 1) specifying the y position
#' of the label showing the most frequent offset (default: \code{0.9}).
#' @param return_offset Logical; if \code{TRUE}, returns the most frequently observed
#' relative offsets instead of plotting (default: \code{FALSE}).
#'
#' @details This function visualizes the distribution of ribosome footprint
#' offsets relative to the start or stop codon. The plot includes read length on
#' the y-axis and relative position on the x-axis. The most frequent offset positions
#' are labeled, and vertical dashed lines highlight expected P-site positions.
#'
#' @return If \code{return_offset = FALSE}, returns a \code{ggplot} object with
#' the relative offset plot. If \code{return_offset = TRUE}, returns a data frame
#' containing the most frequently observed offsets.
#'
#' @examples
#' \dontrun{
#'   # Generate summary information before plotting
#'   ribo_obj <- generate_summary(ribo_obj)
#'
#'   # Plot relative offsets with default parameters
#'   relative_offset_plot(ribo_obj)
#'
#'   # Get the most frequent offset information
#'   offsets <- relative_offset_plot(ribo_obj, return_offset = TRUE)
#' }
#'
#' @seealso \code{\link{generate_summary}}
#'
#' @export
#' @rdname relative_offset_plot
setMethod("relative_offset_plot",
          signature(object = "ribotrans"),
          function(object,
                   type = c("rel2start","rel2stop"),
                   read_length = c(20,35),
                   rel_dist = c(-30,30),
                   rm_yaxis_label = TRUE,
                   max_offset_labelx = 0.9,
                   max_offset_labely = 0.9,
                   return_offset = FALSE){

            type <- match.arg(type,choices = c("rel2start","rel2stop"))

            # check data
            if(nrow(object@summary_info) == 0){
              stop("Please run `generate_summary` first!")
            }

            # extarct data to plot
            if(type == "rel2start"){
              summary.info <- object@summary_info %>%
                fastplyr::f_filter(mstart > 0 & mstop > 0) %>%
                dplyr::mutate(rel_pos = pos - mstart)

              xlab <- "Distance to start codon (nt)"
              xpos <- c(-12,-15,-18)
            }else{
              summary.info <- object@summary_info %>%
                fastplyr::f_filter(mstart > 0 & mstop > 0) %>%
                dplyr::mutate(rel_pos = pos - mstop)

              xlab <- "Distance to stop codon (nt)"
              xpos <- c(12,15,18)
            }

            # filter data
            summary.info <- summary.info %>%
              fastplyr::f_filter(rel_pos >= rel_dist[1] & rel_pos <= rel_dist[2]) %>%
              fastplyr::f_filter(qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
              fastplyr::f_group_by(sample, rel_pos, qwidth) %>%
              fastplyr::f_summarise(counts = sum(count))

            # check y axis
            if(rm_yaxis_label == TRUE){
              axis.text.y = element_blank()
              axis.ticks.y = element_blank()
            }else{
              axis.text.y = NULL
              axis.ticks.y = NULL
            }

            # max offset position
            mx.pos <- summary.info %>%
              dplyr::slice_max(order_by = counts,n = 1,by = c(sample,qwidth))

            if (requireNamespace("ggpp", quietly = TRUE)) {
              mx.label <- ggpp::geom_label_npc(data = mx.pos,aes(npcx = max_offset_labelx,
                                                                 npcy = max_offset_labely,
                                                                 label = rel_pos))
            } else {
              warning("Package 'ggpp' is needed for this function to work.")
              mx.label <- NULL
            }


            # plot
            p <-
              ggplot(summary.info) +
              geom_path(aes(x = rel_pos,y = counts)) +
              mx.label +
              geom_vline(xintercept = xpos,lty ="dashed", color = "orange") +
              ggh4x::facet_grid2(qwidth~sample,scales = "free",independent = "y",axes = "y") +
              theme(axis.text = element_text(colour = "black"),
                    panel.grid = element_blank(),
                    axis.text.y = axis.text.y,
                    axis.ticks.y = axis.ticks.y,
                    strip.text = element_text(colour = "black",size = rel(1),face = "bold")) +
              scale_fill_viridis_c(option = "mako") +
              scale_y_continuous(labels = scales::label_log(base = 10,digits = 1)) +
              xlab(xlab) +
              ylab("Reads length (nt)")


            # check return type
            if(return_offset == FALSE){
              return(p)
            }else{
              return(mx.pos)
            }

          }
)

# ==============================================================================
# function for metagene plot
# ==============================================================================

#' Generate Metagene Profile Plot
#'
#' @description A generic function to generate a metagene profile plot
#' visualizing read distributions relative to start or stop codons.
#'
#' @param object An object containing sequencing data.
#' @param ... Additional arguments passed to specific methods.
#'
#' @return A `ggplot2` object showing the metagene profile distribution.
#'
#' @export
setGeneric("metagene_plot",function(object,...) standardGeneric("metagene_plot"))



#' @describeIn metagene_plot Generate a metagene profile plot for `ribotrans` objects.
#'
#' @description This method creates a metagene profile plot showing the
#' distribution of ribosome-protected fragments (RPFs) relative to the
#' start or stop codon.
#'
#' @param object A `ribotrans` object containing RNA sequencing metrics.
#' @param type Character string specifying the metagene type. Must be one of:
#' \itemize{
#'   \item `"rel2start"` - Distance relative to the start codon.
#'   \item `"rel2stop"` - Distance relative to the stop codon.
#' }
#' @param smooth Logical indicating if a rolling average should be applied to smooth the data (default: `FALSE`).
#' @param return_data Logical, if `TRUE`, returns the processed data instead of a plot (default: `FALSE`).
#' @param show_frame Logical, if `TRUE`, visualizes data by reading frame (default: `FALSE`).
#' @param read_length Numeric vector of length two specifying the range of read lengths to include (default: `c(25,31)`).
#' @param slide_window Integer defining the sliding window size for smoothing when `smooth = TRUE` (default: `3`).
#' @param rel2st_dist Numeric vector of length two, specifying distance range to include relative to start codon (default: `c(-50,100)`).
#' @param rel2sp_dist Numeric vector of length two, specifying distance range to include relative to stop codon (default: `c(-100,50)`).
#' @param facet_wrap A `ggplot2::facet_wrap()` object to control faceting by sample (default behavior).
#'
#' @return If `return_data = FALSE`, returns a `ggplot2` object showing the metagene profile plot.
#' If `return_data = TRUE`, returns a processed `data.frame` containing metagene read distributions.
#'
#' @details
#' - The function normalizes read counts based on total mapped reads (RPM normalization).
#' - Optionally, it applies a rolling average (`slide_window`) to smooth the profile.
#' - If `show_frame = TRUE`, colors are applied for individual reading frames.
#'
#' @examples
#' \dontrun{
#' # Generate standard metagene plot relative to start codon
#' metagene_plot(ribo_obj, type = "rel2start")
#'
#' # Generate smoothed metagene plot
#' metagene_plot(ribo_obj, type = "rel2stop", smooth = TRUE, slide_window = 3)
#'
#' # Get the underlying data instead of a plot
#' data <- metagene_plot(ribo_obj, type = "rel2start", return_data = TRUE)
#' head(data)
#' }
#'
#' @importFrom ggplot2 ggplot geom_line scale_color_manual facet_wrap
#' @importFrom ggplot2 theme element_text element_blank
#' @importFrom dplyr mutate filter left_join select summarise
#' @importFrom fastplyr f_group_by f_summarise f_filter f_select f_left_join
#' @importFrom purrr map_df
#'
#' @export
setMethod("metagene_plot",
          signature(object = "ribotrans"),
          function(object,
                   type = c("rel2start","rel2stop"),
                   smooth = FALSE,
                   return_data = FALSE,
                   show_frame = FALSE,
                   read_length = c(25,31),
                   slide_window = 3,
                   rel2st_dist = c(-50,100),
                   rel2sp_dist = c(-100,50),
                   facet_wrap = ggplot2::facet_wrap(~sample)){
            type <- match.arg(type, choices = c("rel2start","rel2stop"))

            features <- object@features

            pltdf <- object@summary_info %>%
              fastplyr::f_filter(mstart != 0 | mstop != 0,
                                 qwidth >= read_length[1] & qwidth <= read_length[2]) %>%
              fastplyr::f_group_by(sample,rname, pos) %>%
              fastplyr::f_summarise(counts = sum(count))

            # get total mapped reads
            lib <- object@library
            dpt <- subset(lib, type == "ribo" & sample %in% unique(pltdf$sample)) %>%
              dplyr::select(mappped_reads,sample)

            # rpm normalization
            pltdf <- pltdf %>%
              dplyr::left_join(y = dpt,by = "sample") %>%
              dplyr::mutate(rpm = (counts/mappped_reads)*10^6) %>%
              dplyr::select(-mappped_reads)

            # total transcipts
            ttt <- length(unique(pltdf$rname))

            pltdf <- pltdf %>%
              fastplyr::f_left_join(y = features[,c("idnew","mstart","mstop")],
                                    by = c("rname" = "idnew"))


            # calculate frame and relative distance
            if(type == "rel2start"){
              pltdf <- pltdf %>%
                dplyr::mutate(frame = (pos - mstart)%%3,
                              rel = pos - mstart) %>%
                fastplyr::f_select(sample,frame,pos,rel,rpm)
            }else{
              pltdf <- pltdf %>%
                dplyr::mutate(frame = (pos - mstop)%%3,
                              rel = pos - mstop) %>%
                fastplyr::f_select(sample,frame,pos,rel,rpm)
            }


            # check whether plot for each read length
            if(show_frame == TRUE){
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample,rel,frame) %>%
                fastplyr::f_summarise(normval = sum(rpm)/ttt)

              pltlayer <- geom_line(aes(x = rel, y = relexp, color = factor(frame)))
              col <- scale_color_manual(values = c("0" = "#663366", "1" = "#996699", "2" = "#CC99CC"),
                                        name ="frame")
            }else{
              pltdf <- pltdf %>%
                fastplyr::f_group_by(sample,rel) %>%
                fastplyr::f_summarise(normval = sum(rpm)/ttt)

              pltlayer <- geom_line(aes(x = rel, y = relexp))
              col <- NULL
            }


            # filter length and distance
            if(type == "rel2start"){
              pltdf <- pltdf %>%
                dplyr::filter(rel >= rel2st_dist[1] & rel <= rel2st_dist[2])

              distrg <- seq(rel2st_dist[1],rel2st_dist[2],1)
            }else{
              pltdf <- pltdf %>%
                dplyr::filter(rel >= rel2sp_dist[1] & rel <= rel2sp_dist[2])

              distrg <- seq(rel2sp_dist[1],rel2sp_dist[2],1)
            }

            # ==================================================================
            # whether smooth data
            if(smooth == TRUE){
              sp <- unique(pltdf$sample)

              # x = 1
              purrr::map_df(seq_along(sp),function(x){
                tmp <- subset(pltdf, sample == sp[x])

                tmp2 <- data.frame(sample = sp[x],rel = distrg)
                tmp2 <- tmp2 %>%
                  dplyr::left_join(y = tmp,by = c("sample","rel"))

                if (requireNamespace("zoo", quietly = TRUE)) {
                  tmp2$smooth <- zoo::rollmean(tmp2$normval, k = slide_window, fill = 0)
                } else {
                  warning("Package 'zoo' is needed for this function to work.")
                }

                return(tmp2)
              })-> sm.df
            }else{
              sm.df <- pltdf %>%
                dplyr::mutate(smooth = normval)

            }


            ave.tmp <- sm.df %>%
              dplyr::group_by(sample) %>%
              dplyr::summarise(allexp = sum(normval)) %>%
              dplyr::mutate(ave = allexp/length(distrg)) %>%
              dplyr::select(sample, ave)

            sm.df <- sm.df %>%
              dplyr::left_join(y = ave.tmp,by = "sample") %>%
              dplyr::mutate(relexp = normval/ave)

            # plot
            p <-
              ggplot(sm.df) +
              pltlayer +
              theme(panel.grid = element_blank(),
                    strip.text = element_text(colour = "black",face = "bold",size = rel(1)),
                    axis.text = element_text(colour = "black")) +
              # facet_wrap(~sample) +
              facet_wrap +
              col +
              xlab("Distance to start/stop codon (nt)") + ylab("Normalized reads")


            # return
            if(return_data == FALSE){
              return(p)
            }else{
              return(sm.df)
            }

          }
)
